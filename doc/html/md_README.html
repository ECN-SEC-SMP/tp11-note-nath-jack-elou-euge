<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SMP Final Projcts: TP 11 noté - Ricochet Robots</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SMP Final Projcts
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_README.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">TP 11 noté - Ricochet Robots</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> </p>
<h1><a class="anchor" id="autotoc_md1"></a>
Contributeurs</h1>
<ul>
<li><a href="https://github.com/Jaaackoo">Jack HASCOËT</a></li>
<li><a href="https://github.com/Nandros">Natha ANDRE</a></li>
<li><a href="https://github.com/euge13301">Eugénie ROQUAIN</a></li>
<li><a href="https://github.com/ioleto">Eloi TOURANGIN</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Professeur</h1>
<ul>
<li>Myriam Servieres</li>
</ul>
<h1><a class="anchor" id="autotoc_md3"></a>
Table des matières</h1>
<ol type="1">
<li>Explication des règles<ul>
<li>Objectif du jeu</li>
<li>Éléments du jeu</li>
<li>Déroulement d’un tour</li>
<li>Règles de déplacement</li>
<li>Remarque</li>
</ul>
</li>
<li>Build &amp; Compilation<ul>
<li>Build</li>
<li>Compilation</li>
</ul>
</li>
<li>Les Classes<ul>
<li>Classe Board<ul>
<li>Fonctionnement classe Board</li>
<li>Algorithmes classe Board</li>
<li>Tests classe Board</li>
</ul>
</li>
<li>Classe Case<ul>
<li>Fonctionnement classe Case</li>
<li>Algorithmes classe Case</li>
<li>Tests classe Case</li>
</ul>
</li>
<li>Classe Display<ul>
<li>Fonctionnement classe Display</li>
<li>Algorithmes classe Display</li>
<li>Tests classe Display</li>
</ul>
</li>
<li>Classe Game<ul>
<li>Fonctionnement classe Game</li>
<li>Algorithmes classe Game</li>
<li>Tests classe Game</li>
</ul>
</li>
<li>Classe Player<ul>
<li>Fonctionnement classe Player</li>
<li>Algorithmes classe Player</li>
<li>Tests classe Player</li>
</ul>
</li>
<li>Classe Robot<ul>
<li>Fonctionnement classe Robot</li>
<li>Algorithmes classe Robot</li>
<li>Tests classe Robot</li>
</ul>
</li>
<li>Classe Target<ul>
<li>Fonctionnement classe Target</li>
<li>Algorithmes classe Target</li>
<li>Tests classe Target</li>
</ul>
</li>
</ul>
</li>
<li>Exemples d'utilisation</li>
</ol>
<h1><a class="anchor" id="autotoc_md4"></a>
Explication des règles</h1>
<h2><a class="anchor" id="autotoc_md5"></a>
Objectif du jeu</h2>
<p>Ricochet Robots est un jeu de plateau où 4 robots de couleurs différentes (rouge, jaune, bleu, vert) se déplacent sur une grille de 16x16 cases. Le but est de déplacer les robots pour amener l’un d’eux sur une case cible spécifique en respectant les règles de déplacement. Le joueur qui trouve la solution en utilisant le moins de mouvements remporte la manche.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Éléments du jeu</h2>
<ul>
<li><b>Robots</b> : 4 robots de couleurs différentes.</li>
<li><b>Objectifs</b> : 17 tuiles cibles réparties en 4 groupes de 4 tuiles de couleur identique à celle des robots, et une tuile multicolore.</li>
<li><b>Plateau</b> : Une grille de 16x16 cases avec des murs et obstacles.</li>
<li><b>Sablier</b> : Un sablier d’une heure pour limiter le temps de réflexion.</li>
</ul>
<h2><a class="anchor" id="autotoc_md7"></a>
Déroulement d’un tour</h2>
<ol type="1">
<li><b>Tirage de la tuile objectif</b> : <br  />
 Le plateau ainsi que la tuile objectif sont affiché. Si c’est une tuile de couleur, le but est d’amener le robot de cette couleur sur la case cible correspondante. Si c’est la tuile multicolore, n’importe quel robot peut atteindre la case multicolore.</li>
<li><b>Réflexion simultanée</b> : <br  />
 Tous les joueurs réfléchissent en même temps pour trouver une solution en utilisant le moins de mouvements possible.</li>
<li><b>Annonce des solutions</b> : <br  />
 Lorsqu’un joueur trouve une solution, il appui sur espace et rentre le nombre de mouvements nécessaires. Les autres joueurs ont une minute pour proposer de meilleures solutions.</li>
<li><b>Validation par déplacement</b> : <br  />
 Le joueur ayant proposé la solution avec le moins de mouvements montre sa solution. Si elle est correcte, il remporte la partie. Sinon, le joueur suivant (ayant proposé le nombre de mouvements immédiatement supérieur) montre sa solution, et ainsi de suite.</li>
</ol>
<h2><a class="anchor" id="autotoc_md8"></a>
Règles de déplacement</h2>
<ul>
<li>Les robots se déplacent en ligne droite et avancent jusqu’à rencontrer un obstacle.</li>
<li>Les obstacles peuvent être :<ul>
<li>Les bords du plateau.</li>
<li>Les murs présents sur le plateau.</li>
<li>Un autre robot.</li>
</ul>
</li>
<li>Une fois en mouvement, un robot ne peut s’arrêter ou changer de direction avant de rencontrer un obstacle.</li>
<li>Chaque déplacement compte pour un mouvement, quel que soit le nombre de cases parcourues.</li>
</ul>
<h2><a class="anchor" id="autotoc_md9"></a>
Remarque</h2>
<p>Si une solution est atteignable en un seul mouvement après le tirage d’une tuile objectif, les joueurs doivent ignorer cette solution et chercher une alternative.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Build &amp; Compilation</h1>
<h2><a class="anchor" id="autotoc_md11"></a>
Build</h2>
<p>Pour construire le projet, exécutez les commandes suivantes dans un terminal :</p>
<div class="fragment"><div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">cmake ..</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md12"></a>
Lancer le jeu</h2>
<p>A la racine du projet, dans un terminale </p><div class="fragment"><div class="line">make</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md13"></a>
Lancer le jeu de test</h2>
<p>A la racine du projet, dans un terminale </p><div class="fragment"><div class="line">cd ./build/</div>
<div class="line">ctest</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
Compilation</h2>
<p>Compiler et lancer le jeu</p>
<div class="fragment"><div class="line">make</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md15"></a>
Classe Board</h1>
<p>La classe <code><a class="el" href="classBoard.html" title="Class to manage game board.">Board</a></code> représente une grille de jeu de 16x16 cases utilisée pour un jeu de type puzzle. Elle contient des méthodes pour générer la grille, placer des murs, des angles, des robots, et des cibles.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Fonctionnement classe Board</h2>
<ol type="1">
<li><b>Attributs principaux :</b><ul>
<li><code>board[16][16]</code> : Tableau 2D de cases représentant la grille de jeu. Chaque case peut contenir des murs, un robot, ou une cible.</li>
</ul>
</li>
<li><b>Méthodes privées :</b><ul>
<li><code>generateBoardStep1</code> : Ajoute les murs extérieurs de la grille et les murs formant un carré central.</li>
<li><code>generateBoardStep2</code> : Ajoute deux murs extérieurs aléatoires (un vertical et un horizontal) dans chaque quart de la grille.</li>
<li><code>generateBoardStep3</code> : Ajoute 4 "angles" (deux murs formant un coin) dans chaque quart de la grille, en s'assurant qu'ils ne touchent pas d'autres murs ou angles.</li>
<li><code>generateBoardStep4</code> : Ajoute un angle supplémentaire dans un quart choisi aléatoirement, en respectant les mêmes contraintes.</li>
</ul>
</li>
<li><b>Méthodes publiques :</b><ul>
<li><code>generateBoard</code> : Génère la grille complète en appelant les étapes 1 à 4.</li>
<li><code>placeRobots</code> : Place aléatoirement 4 robots sur la grille, ainsi qu'une cible dans un angle de deux murs.</li>
<li><code>getBoard</code> : Retourne la grille de jeu.</li>
<li>Constructeur et destructeur : Initialisent et nettoient la grille.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md17"></a>
Algorithmes classe Board</h2>
<p>Voici l'algorithme en langage naturel pour générer une grille complète et gérer les fonctionnalités de la classe <code><a class="el" href="classBoard.html" title="Class to manage game board.">Board</a></code> :</p>
<div class="fragment"><div class="line">type Case</div>
<div class="line">    entier nord</div>
<div class="line">    entier sud</div>
<div class="line">    entier est</div>
<div class="line">    entier ouest</div>
<div class="line">    lien Robot robot</div>
<div class="line">    lien Target cible</div>
<div class="line">fin type</div>
<div class="line"> </div>
<div class="line">type Board</div>
<div class="line">    tableau[16][16] de Case grille</div>
<div class="line">    tableau[16][16] de Case grilleInitiale</div>
<div class="line">    tableau dynamique de paires (entier, entier) anglesCoordinates</div>
<div class="line">    Target objectifCible</div>
<div class="line">fin type</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md18"></a>
Génération de la grille</h3>
<div class="fragment"><div class="line">fonction ø &lt;- generateBoard(B)</div>
<div class="line">algorithme</div>
<div class="line">    appeler generateBoardStep1(B)</div>
<div class="line">    appeler generateBoardStep2(B)</div>
<div class="line">    appeler generateBoardStep3(B)</div>
<div class="line">    appeler generateBoardStep4(B)</div>
<div class="line">fin fonction</div>
</div><!-- fragment --><div class="fragment"><div class="line">fonction ø &lt;- generateBoardStep1(B)</div>
<div class="line">    paramètre lien Board B</div>
<div class="line">    résultat ø</div>
<div class="line">algorithme</div>
<div class="line">    pour x allant de 0 à 15 faire</div>
<div class="line">        B.grille[x][0].nord &lt;- 1</div>
<div class="line">        B.grille[x][15].sud &lt;- 1</div>
<div class="line">    fin pour</div>
<div class="line"> </div>
<div class="line">    pour y allant de 0 à 15 faire</div>
<div class="line">        B.grille[0][y].ouest &lt;- 1</div>
<div class="line">        B.grille[15][y].est &lt;- 1</div>
<div class="line">    fin pour</div>
<div class="line"> </div>
<div class="line">    B.grille[7][7].nord &lt;- 1</div>
<div class="line">    B.grille[7][7].ouest &lt;- 1</div>
<div class="line">    B.grille[7][8].ouest &lt;- 1</div>
<div class="line">    B.grille[7][8].sud &lt;- 1</div>
<div class="line">    B.grille[8][7].nord &lt;- 1</div>
<div class="line">    B.grille[8][7].est &lt;- 1</div>
<div class="line">    B.grille[8][8].est &lt;- 1</div>
<div class="line">    B.grille[8][8].sud &lt;- 1</div>
<div class="line">fin fonction</div>
</div><!-- fragment --><div class="fragment"><div class="line">fonction ø &lt;- generateBoardStep2(B)</div>
<div class="line">    paramètre lien Board B</div>
<div class="line">    résultat ø</div>
<div class="line">algorithme</div>
<div class="line">    pour chaque quart de la grille faire</div>
<div class="line">        générer x et y aléatoires dans les limites du quart</div>
<div class="line">        si les murs générés ne touchent pas d&#39;autres murs alors</div>
<div class="line">            placer un mur vertical ou horizontal</div>
<div class="line">        fin si</div>
<div class="line">    fin pour</div>
<div class="line">fin fonction</div>
</div><!-- fragment --><div class="fragment"><div class="line">fonction ø &lt;- generateBoardStep3(B)</div>
<div class="line">    paramètre lien Board B</div>
<div class="line">    résultat ø</div>
<div class="line">algorithme</div>
<div class="line">    pour chaque quart de la grille faire</div>
<div class="line">        compteur angles &lt;- 0</div>
<div class="line">        tant que compteur angles &lt; 4 faire</div>
<div class="line">            générer x et y aléatoires dans les limites du quart</div>
<div class="line">            si la case (x, y) n&#39;est pas occupée par un mur ou un angle alors</div>
<div class="line">                générer un type d&#39;angle aléatoire</div>
<div class="line">                si l&#39;angle est valide (ne touche pas un autre angle ou mur extérieur) alors</div>
<div class="line">                    placer l&#39;angle en activant deux murs adjacents</div>
<div class="line">                    ajouter (x, y) à anglesCoordinates</div>
<div class="line">                    incrémenter compteur angles</div>
<div class="line">                fin si</div>
<div class="line">            fin si</div>
<div class="line">        fin tant que</div>
<div class="line">    fin pour</div>
<div class="line">fin fonction</div>
</div><!-- fragment --><div class="fragment"><div class="line">fonction ø &lt;- generateBoardStep4(B)</div>
<div class="line">    paramètre lien Board B</div>
<div class="line">    résultat ø</div>
<div class="line">algorithme</div>
<div class="line">    répéter</div>
<div class="line">        générer x et y aléatoires dans toute la grille (hors murs extérieurs)</div>
<div class="line">        si la case (x, y) n&#39;est pas occupée par un mur ou un angle alors</div>
<div class="line">            générer un type d&#39;angle aléatoire</div>
<div class="line">            si l&#39;angle est valide (ne touche pas un autre angle ou mur extérieur) alors</div>
<div class="line">                placer l&#39;angle en activant deux murs adjacents</div>
<div class="line">                ajouter (x, y) à anglesCoordinates</div>
<div class="line">                arrêter la boucle</div>
<div class="line">            fin si</div>
<div class="line">        fin si</div>
<div class="line">    jusqu&#39;à ce qu&#39;un angle soit placé</div>
<div class="line">fin fonction</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md19"></a>
Placement des robots et des cibles</h3>
<div class="fragment"><div class="line">fonction ø &lt;- placeRobots(B, robots)</div>
<div class="line">    paramètre lien Board B</div>
<div class="line">    paramètre tableau[4] de Robot robots</div>
<div class="line">    résultat ø</div>
<div class="line">algorithme</div>
<div class="line">    compteur robots placés &lt;- 0</div>
<div class="line">    tant que compteur robots placés &lt; 4 faire</div>
<div class="line">        générer x et y aléatoires dans toute la grille (hors carré central)</div>
<div class="line">        si la case (x, y) est libre (pas de robot, pas de cible) alors</div>
<div class="line">            placer un robot sur la case</div>
<div class="line">            mettre à jour ses coordonnées initiales</div>
<div class="line">            incrémenter compteur robots placés</div>
<div class="line">        fin si</div>
<div class="line">    fin tant que</div>
<div class="line">fin fonction</div>
</div><!-- fragment --><div class="fragment"><div class="line">fonction ø &lt;- placeTargets(B, targets)</div>
<div class="line">    paramètre lien Board B</div>
<div class="line">    paramètre tableau dynamique de Target targets</div>
<div class="line">    résultat ø</div>
<div class="line">algorithme</div>
<div class="line">    pour chaque couleur de cible faire</div>
<div class="line">        pour chaque cible de cette couleur faire</div>
<div class="line">            choisir un angle aléatoire dans anglesCoordinates</div>
<div class="line">            si l&#39;angle est libre (pas de robot, pas de cible) alors</div>
<div class="line">                placer la cible sur la case</div>
<div class="line">            fin si</div>
<div class="line">        fin pour</div>
<div class="line">    fin pour</div>
<div class="line"> </div>
<div class="line">    si une cible multicolore doit être placée alors</div>
<div class="line">        choisir un angle aléatoire dans anglesCoordinates</div>
<div class="line">        si l&#39;angle est libre alors</div>
<div class="line">            placer la cible multicolore</div>
<div class="line">        fin si</div>
<div class="line">    fin si</div>
<div class="line">fin fonction</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md20"></a>
Déplacement des robots</h3>
<div class="fragment"><div class="line">fonction booléen &lt;- moveRobot(B, robot, direction)</div>
<div class="line">    paramètre lien Board B</div>
<div class="line">    paramètre Robot robot</div>
<div class="line">    paramètre caractère direction</div>
<div class="line">    résultat booléen</div>
<div class="line">algorithme</div>
<div class="line">    récupérer les coordonnées actuelles du robot</div>
<div class="line">    tant que le robot peut avancer dans la direction donnée faire</div>
<div class="line">        vérifier les murs, les bords du plateau et les autres robots</div>
<div class="line">        mettre à jour les coordonnées du robot</div>
<div class="line">    fin tant que</div>
<div class="line">    retourner vrai si le robot a bougé, sinon faux</div>
<div class="line">fin fonction</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md21"></a>
Vérification de l'objectif</h3>
<div class="fragment"><div class="line">fonction booléen &lt;- targetReached(B, robot)</div>
<div class="line">    paramètre lien Board B</div>
<div class="line">    paramètre Robot robot</div>
<div class="line">    résultat booléen</div>
<div class="line">algorithme</div>
<div class="line">    récupérer la cible sur la case actuelle du robot</div>
<div class="line">    si la cible existe et correspond à l&#39;objectif alors</div>
<div class="line">        retourner vrai</div>
<div class="line">    sinon</div>
<div class="line">        retourner faux</div>
<div class="line">    fin si</div>
<div class="line">fin fonction</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md22"></a>
Sauvegarde et réinitialisation de la grille</h3>
<div class="fragment"><div class="line">fonction ø &lt;- saveBoard(B)</div>
<div class="line">    paramètre lien Board B</div>
<div class="line">    résultat ø</div>
<div class="line">algorithme</div>
<div class="line">    copier la grille actuelle dans grilleInitiale</div>
<div class="line">fin fonction</div>
</div><!-- fragment --><div class="fragment"><div class="line">fonction ø &lt;- reinitBoard(B, robots)</div>
<div class="line">    paramètre lien Board B</div>
<div class="line">    paramètre tableau dynamique de Robot robots</div>
<div class="line">    résultat ø</div>
<div class="line">algorithme</div>
<div class="line">    restaurer grilleInitiale dans grille</div>
<div class="line">    pour chaque robot faire</div>
<div class="line">        réinitialiser ses coordonnées à ses coordonnées initiales</div>
<div class="line">        remettre le robot sur la grille</div>
<div class="line">    fin pour</div>
<div class="line">fin fonction</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md23"></a>
Tests classe Board</h2>
<p>Les tests de la classe <code><a class="el" href="classBoard.html" title="Class to manage game board.">Board</a></code> permettent de valider les fonctionnalités principales de cette classe, notamment la génération de la grille, le placement des éléments (robots et cibles), les déplacements des robots, et la gestion des objectifs.</p>
<h3><a class="anchor" id="autotoc_md24"></a>
1. Test du constructeur (&lt;tt&gt;ConstructorTest&lt;/tt&gt;)</h3>
<ul>
<li><b>Objectif</b> : Vérifier que la grille de jeu est correctement initialisée.</li>
<li><b>Vérifications</b> :<ul>
<li>Les murs extérieurs sont correctement placés (les bords de la grille).</li>
<li>Les murs formant le carré central sont correctement générés.</li>
<li>Les cases sans murs ne contiennent ni robots ni cibles.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md25"></a>
2. Test du placement des cibles (&lt;tt&gt;PlaceTargetsTest&lt;/tt&gt;)</h3>
<ul>
<li><b>Objectif</b> : Vérifier que les cibles sont placées correctement sur la grille.</li>
<li><b>Vérifications</b> :<ul>
<li>Les cibles sont placées uniquement dans des angles valides (cases avec deux murs adjacents).</li>
<li>Le nombre de cibles placées est compris entre 4 (minimum) et 17 (maximum, incluant la cible multicolore).</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md26"></a>
3. Test du déplacement des robots (&lt;tt&gt;MoveRobotTest&lt;/tt&gt;)</h3>
<ul>
<li><b>Objectif</b> : Vérifier que les robots se déplacent correctement selon les règles du jeu.</li>
<li><b>Vérifications</b> :<ul>
<li>Un robot peut se déplacer dans une direction donnée (N, S, E, W) tant qu'il ne rencontre pas :<ul>
<li>Un mur.</li>
<li>Un autre robot.</li>
<li>Les bords de la grille.</li>
</ul>
</li>
<li>Si un déplacement est possible, les coordonnées du robot sont mises à jour.</li>
<li>Si un déplacement n'est pas possible, les coordonnées du robot restent inchangées.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md27"></a>
4. Test de sauvegarde et réinitialisation de la grille (&lt;tt&gt;SaveAndReinitBoardTest&lt;/tt&gt;)</h3>
<ul>
<li><b>Objectif</b> : Vérifier que la grille peut être sauvegardée et réinitialisée correctement.</li>
<li><b>Vérifications</b> :<ul>
<li>Après avoir sauvegardé l'état initial de la grille, un robot est déplacé.</li>
<li>Lors de la réinitialisation, le robot revient à sa position initiale, et la grille retrouve son état sauvegardé.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md28"></a>
5. Test de la vérification de l'objectif (&lt;tt&gt;TargetReachedTest&lt;/tt&gt;)</h3>
<ul>
<li><b>Objectif</b> : Vérifier si un robot atteint une cible correspondant à l'objectif.</li>
<li><b>Vérifications</b> :<ul>
<li>Si un robot est placé sur une case contenant une cible correspondant à l'objectif (même couleur et forme), la fonction retourne <code>true</code>.</li>
<li>Sinon, la fonction retourne <code>false</code>.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md29"></a>
6. Test des méthodes &lt;tt&gt;setTargetObjectif&lt;/tt&gt; et &lt;tt&gt;getTargetObjectif&lt;/tt&gt; (&lt;tt&gt;TargetObjectifTest&lt;/tt&gt;)</h3>
<ul>
<li><b>Objectif</b> : Vérifier que l'objectif (cible à atteindre) est correctement défini et récupéré.</li>
<li><b>Vérifications</b> :<ul>
<li>La méthode <code>setTargetObjectif</code> permet de définir une cible comme objectif.</li>
<li>La méthode <code>getTargetObjectif</code> retourne correctement la cible définie comme objectif.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md30"></a>
Classe Case</h1>
<h2><a class="anchor" id="autotoc_md31"></a>
Fonctionnement classe Case</h2>
<h2><a class="anchor" id="autotoc_md32"></a>
Algorithmes classe Case</h2>
<h2><a class="anchor" id="autotoc_md33"></a>
Tests classe Case</h2>
<h1><a class="anchor" id="autotoc_md34"></a>
Classe Display</h1>
<p>La classe <code><a class="el" href="classDisplay.html" title="Class to display the game.">Display</a></code> sert à générer un affichage visuel en console d’un plateau de jeu, avec une représentation graphique ASCII des murs, des robots et des cibles (les targets). Elle utilise des codes ANSI pour afficher les couleurs et des caractères Unicode pour les formes.</p>
<h2><a class="anchor" id="autotoc_md35"></a>
Fonctionnement classe Display</h2>
<ol type="1">
<li><b>Attributs principaux :</b><ul>
<li><code>board[SIZE_BOARD][SIZE_BOARD]</code> : Tableau 2D de cases représentant la grille de jeu. Chaque case peut contenir des murs, un robot, ou une cible. SIZE_BOARD = int(16)</li>
<li><code>dispBoard[BOARD_DISP_SIZE][BOARD_DISP_SIZE]</code> : Affichage visuel du plateau.</li>
<li><code>DispCaseDir_t</code> : enum privé pour gérer la direction des cases.</li>
</ul>
</li>
<li><b>Méthodes privées :</b><ul>
<li><code>put_walls</code> : Parcourt chaque <a class="el" href="classCase.html" title="Model class for cases.">Case</a> pour afficher les murs selon les directions -&gt; Nord, Sud, Est, Ouest.</li>
<li><code>put_robots</code> : Vérifie si un robot est présent dans la case. Si oui, récupère sa couleur et sa forme, prépare une chaîne à afficher.</li>
<li><code>put_targets</code> : Affichage des cibles.</li>
</ul>
</li>
<li><b>Méthodes publiques :</b><ul>
<li><code>update(Case board[SIZE_BOARD][SIZE_BOARD])</code> : Met à jour le plateau. Dans l'ordre : 1 - Génère ligne par ligne les caractères ASCII à afficher. 2 - Appelle trois fonctions privées pour : afficher les murs, afficher les robots, afficher les cibles.</li>
<li><code>print</code> : Place aléatoirement 4 robots sur la grille, ainsi qu'une cible dans un angle de deux murs.</li>
<li>Constructeur et destructeur <code><a class="el" href="classDisplay.html" title="Class to display the game.">Display()</a></code>: initialise l’affichage (mise en forme console avec ANSI) et réinitialise les couleurs et efface l’écran.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md36"></a>
Algorithmes classe Display</h2>
<div class="fragment"><div class="line">fonction ø &lt;- put_walls</div>
<div class="line">    paramètre curCase, x, y</div>
<div class="line">    résultat ø</div>
<div class="line">algorithme</div>
<div class="line">    pour chaque case du plateau</div>
<div class="line">        curCase predn la valeur de la case actuelle</div>
<div class="line">        x et y prennent les coordonnées du plateau</div>
<div class="line"> </div>
<div class="line">        si curCase est faux</div>
<div class="line">            continuer</div>
<div class="line">        si curcase.getNorth est vrai</div>
<div class="line">            afficher un mur horizontal au coordonnées : dispBoard[x - 1][y]</div>
<div class="line">        si curcase.getSouth </div>
<div class="line">            afficher un mur horizontal au coordonnées : dispBoard[x + 1][y]</div>
<div class="line">        si curCase.getEast est vrai</div>
<div class="line">            afficher un mur horizontal au coordonnées : dispBoard[x][y + 1]</div>
<div class="line">        si curCase.getWest est vrai</div>
<div class="line">            afficher un mur horizontal au coordonnées : dispBoard[x][y - 1]</div>
<div class="line">        fin si</div>
<div class="line">    fin pour</div>
<div class="line"> </div>
<div class="line">    initialisation des valeurs booléenne wbot, wtop, wrgt, wlft</div>
<div class="line">    pour chaque case</div>
<div class="line">        to_put prend un espace vide</div>
<div class="line">        si la case = coin supérieur gauche du plateau alors</div>
<div class="line">            wrgt : recherche d&#39;un mur horizontal à droite de ce coin</div>
<div class="line">            wbot : recherche d&#39;un mur vertical en dessous</div>
<div class="line">            si wrgt &amp;&amp; wbot alors</div>
<div class="line">                affiche coin complet</div>
<div class="line">            si wbot alors</div>
<div class="line">                Un coin avec seulement un mur vertical</div>
<div class="line">            si wrgt alors</div>
<div class="line">                Un coin avec seulement un mur horizontal</div>
<div class="line">            fin si</div>
<div class="line">        fin si</div>
<div class="line">    fin pour</div>
<div class="line">fin fonction</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md37"></a>
Tests classe Display</h2>
<h1><a class="anchor" id="autotoc_md38"></a>
Classe Game</h1>
<h2><a class="anchor" id="autotoc_md39"></a>
Fonctionnement classe Game</h2>
<p>Notre classe <a class="el" href="classGame.html" title="Control class for the game.">Game</a> comprend deux classes : <a class="el" href="classBoard.html" title="Class to manage game board.">Board</a> et <a class="el" href="classDisplay.html" title="Class to display the game.">Display</a>. Elle permet d'initialiser le jeu et ainsi démarrer une partie.</p>
<p>Dans notre classe <a class="el" href="classBoard.html" title="Class to manage game board.">Board</a> on a 4 attributs :</p>
<ul>
<li>moveRobot() qui permet d'avancer les pions <a class="el" href="classRobot.html" title="Model class for robots.">Robot</a> en ligne jusqu'à un obstacle</li>
<li>generateBoard() qui permet de générer de facon aléatoire notre plateau de jeu avec des obstacles, les cibles et les pions Robots</li>
<li>CheckWall(x,y) qui prend en argument les coordonnées de la case et qui vérifie si notre pion robot est face à un mur</li>
<li><p class="startli">CheckTarget(x,y) qui prend en argument les coordonnées de la case et qui vérifie si la case x,y à un pion robot ou non</p>
<p class="startli">La classe <a class="el" href="classBoard.html" title="Class to manage game board.">Board</a> utilise les enum Colors et Shapes qui ont respectivement chacune des couleurs des cibles et robots ainsi que les formes deux cibles</p>
<p class="startli">Dans notre classe <a class="el" href="classDisplay.html" title="Class to display the game.">Display</a> on a 2 arguments :</p>
</li>
<li>Updates()</li>
<li><p class="startli">Print()</p>
<p class="startli">Notre classe <a class="el" href="classRobot.html" title="Model class for robots.">Robot</a> possède deux arguments :</p>
</li>
<li>getShape()</li>
<li>getColor()</li>
<li><a class="el" href="classRobot.html" title="Model class for robots.">Robot(Enum Colors)</a> qui lui attribut une couleur</li>
<li><a class="el" href="classRobot.html" title="Model class for robots.">Robot(Color c, Shape s)</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md40"></a>
Algorithmes classe Game</h2>
<p>La fonction play() est celle qui orchestre le jeu, permet à tel ou tel joueur de jouer, de faire l'attribution des scores et de relancer une tuile. </p><div class="fragment"><div class="line">fonction booléen &lt;- play()</div>
<div class="line">    paramètre aucun</div>
<div class="line">    résultat booléen</div>
<div class="line"> </div>
<div class="line">algorithme</div>
<div class="line">    créer une nouvelle interface d&#39;affichage</div>
<div class="line">    initialiser le plateau temporaire de 16x16 cases</div>
<div class="line">    initialiser les joueurs, robots et cibles</div>
<div class="line">    sauvegarder l’état initial du plateau</div>
<div class="line">    initialiser l’index de la cible à -1</div>
<div class="line"> </div>
<div class="line">    boucle faire tant que keepPlaying() retourne vrai</div>
<div class="line">        réinitialiser l&#39;affichage des robots et du pseudo</div>
<div class="line">        désactiver les événements clavier</div>
<div class="line"> </div>
<div class="line">        réinitialiser la position des robots sur le plateau</div>
<div class="line">        incrémenter l’index de la cible</div>
<div class="line">        définir la nouvelle cible sur le plateau</div>
<div class="line">        sauvegarder l’état actuel du plateau</div>
<div class="line"> </div>
<div class="line">        afficher l’état du plateau</div>
<div class="line">        réinitialiser le nombre de coups des joueurs</div>
<div class="line"> </div>
<div class="line">        si aucun joueur ne propose de solution alors</div>
<div class="line">            afficher un message d’échec collectif</div>
<div class="line">            retourner vrai</div>
<div class="line">        fin si</div>
<div class="line"> </div>
<div class="line">        permettre au premier joueur d’annoncer son nombre de coups</div>
<div class="line">        donner aux autres joueurs une minute pour proposer le leur</div>
<div class="line">        ordonner les joueurs par ordre croissant de coups annoncés</div>
<div class="line"> </div>
<div class="line">        activer la gestion des événements clavier pour les mouvements et la sélection des robots</div>
<div class="line">        sauvegarder les événements précédents</div>
<div class="line"> </div>
<div class="line">        mettre à jour l’affichage des robots disponibles</div>
<div class="line"> </div>
<div class="line">        démarrer la boucle de jeu joueur par joueur</div>
<div class="line">            pour chaque joueur</div>
<div class="line">                initialiser l’état du jeu pour ce joueur</div>
<div class="line">                afficher le plateau actuel</div>
<div class="line"> </div>
<div class="line">                remettre les compteurs de mouvement à zéro</div>
<div class="line">                choisir le robot de départ</div>
<div class="line">                afficher l’indicateur de mouvements</div>
<div class="line"> </div>
<div class="line">                si le joueur a annoncé un nombre de coups</div>
<div class="line">                    afficher à qui c’est le tour</div>
<div class="line"> </div>
<div class="line">                    tant que le joueur joue</div>
<div class="line">                        attendre un petit délai</div>
<div class="line">                        si un nouvel événement de sélection de robot alors</div>
<div class="line">                            traiter l’événement</div>
<div class="line">                        sinon si un nouvel événement de mouvement alors</div>
<div class="line">                            traiter l’événement</div>
<div class="line">                        fin si</div>
<div class="line"> </div>
<div class="line">                        si aucun mouvement n’a eu lieu alors</div>
<div class="line">                            continuer à la prochaine itération</div>
<div class="line">                        fin si</div>
<div class="line"> </div>
<div class="line">                        désactiver le drapeau de rafraîchissement</div>
<div class="line">                        si le joueur a atteint le nombre de coups annoncés alors</div>
<div class="line">                            continuer à la prochaine itération</div>
<div class="line">                        fin si</div>
<div class="line"> </div>
<div class="line">                        incrémenter le nombre de coups réalisés</div>
<div class="line">                        mettre à jour l&#39;affichage des coups</div>
<div class="line"> </div>
<div class="line">                        rafraîchir le plateau</div>
<div class="line"> </div>
<div class="line">                        si la cible a été atteinte alors</div>
<div class="line">                            si c’est au 1er coup, alors</div>
<div class="line">                                annuler la victoire et réinitialiser la partie pour ce joueur</div>
<div class="line">                            sinon</div>
<div class="line">                                marquer le joueur comme gagnant</div>
<div class="line">                                mettre fin à son tour</div>
<div class="line">                                mettre à jour son score (2 si exact, 1 sinon)</div>
<div class="line">                                afficher le message de victoire</div>
<div class="line">                        sinon si le joueur a atteint son nombre de coups sans succès alors</div>
<div class="line">                            afficher le message d’échec</div>
<div class="line">                            mettre fin à son tour</div>
<div class="line">                        fin si</div>
<div class="line">                    fin tant que</div>
<div class="line">                fin si</div>
<div class="line"> </div>
<div class="line">                si un joueur a gagné alors</div>
<div class="line">                    sortir de la boucle principale</div>
<div class="line">                fin si</div>
<div class="line"> </div>
<div class="line">                réinitialiser le plateau</div>
<div class="line">            fin pour chaque joueur</div>
<div class="line">        fin de boucle joueur</div>
<div class="line"> </div>
<div class="line">    fin faire tant que keepPlaying() est vrai</div>
<div class="line"> </div>
<div class="line">    afficher le score final</div>
<div class="line">    retourner vrai</div>
<div class="line">fin fonction</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md41"></a>
Tests classe Game</h2>
<h1><a class="anchor" id="autotoc_md42"></a>
Classe Player</h1>
<h2><a class="anchor" id="autotoc_md43"></a>
Fonctionnement classe Player</h2>
<h2><a class="anchor" id="autotoc_md44"></a>
Algorithmes classe Player</h2>
<h2><a class="anchor" id="autotoc_md45"></a>
Tests classe Player</h2>
<h1><a class="anchor" id="autotoc_md46"></a>
Classe Robot</h1>
<p>La classe <code><a class="el" href="classRobot.html" title="Model class for robots.">Robot</a></code> représente ses caractéristiques : couleur (Color), forme (Shape), coordonnées en 2D (x, y)</p>
<h2><a class="anchor" id="autotoc_md47"></a>
Fonctionnement classe Robot</h2>
<ol type="1">
<li><b>Attributs principaux :</b><ul>
<li></li>
</ul>
</li>
<li><b>Méthodes privées :</b><ul>
<li><code>color</code> : couleur du robot</li>
<li><code>shape</code> : forme du robot</li>
<li><code>x</code> : position en x du robot</li>
<li><code>y</code> : position en y du robot</li>
</ul>
</li>
<li><b>Méthodes publiques :</b><ul>
<li>Constructeur et destructeur : <code><a class="el" href="classRobot.html" title="Model class for robots.">Robot()</a></code> : Crée un robot vert de forme RobotSign, <code><a class="el" href="classRobot.html" title="Model class for robots.">Robot(Color c)</a></code> crée le robot avec la couleur de notre choix.</li>
<li><code>getColor()</code>, <code>getShape()</code>, <code>getX()</code>, <code>getY()</code> : Retourne respectivement la couleur, la forme, ses coordonnées en x et y.</li>
<li><code>setColor(Color)</code>, <code>setShape(Shape)</code>, <code>setX(int)</code>, <code>setY(int)</code> : Change respectivement la couleur, la forme, ses coordonnées en x et y.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md48"></a>
Algorithmes classe Robot</h2>
<h2><a class="anchor" id="autotoc_md49"></a>
Tests classe Robot</h2>
<h1><a class="anchor" id="autotoc_md50"></a>
Classe Target</h1>
<h2><a class="anchor" id="autotoc_md51"></a>
Fonctionnement classe Target</h2>
<h2><a class="anchor" id="autotoc_md52"></a>
Algorithmes classe Target</h2>
<h2><a class="anchor" id="autotoc_md53"></a>
Tests classe Target</h2>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
